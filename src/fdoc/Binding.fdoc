@h1 Embedding C++ in Felix
@h2 Basic Bindings
In the previous examples, we've use the Felix standard
library. It's time to look at how it works.

The Felix language is somewhat novel in that there
are no primitive data types, not even bool.
Instead, Felix uses binding definitions to declare
abstract primitive data types, and bind them to
concrete C++ data type.

Here is an example of a binding.


@flx-and-expect tut/embedding/bind-1.01-0

There are lots of things to note here.

First, the header statement

<pre>
  header """ .... """;
</pre>

specifies text to
be emitted literally in the generated C++ header file:
note the trailing semicolon.
In this case, we emit a C++ class defining
a basic gaussian integer type. There is also a
'body' keyword to literally emit code in the
generated implementation (body) file.

Next, we define the felix type gauss.

<pre>
  type gauss = "gauss";
</pre>

The definition specifies the Felix name, gauss,
and then the C++ name, which also happens to be
gauss.

Then we define the semantics of our new primitive
by primitive functions and procedures which allow
us to manipulate it. Theses consists of a function
or procedure name, a type, and the C++ code to
generate when the function or procedure is called.

@felix
proc _set : &gauss * gauss = "*$1 = $2;";
fun add: gauss * gauss -> gauss = "$1 + $2";
fun mul: gauss * gauss -> gauss = "$1 * $2";
fun mkgauss: int * int -> gauss = "gauss($1,$2)";
fun real: gauss -> int = "$1.x";
fun imag: gauss -> int = "$1.y";
@

In the definition string, $1 means the first argument
of the argument tuple, and $2 means the second, etc.

If the type of an argument component is prefixed
by a &amp;, this means that a pointer is passed.

You should note that there is a predefined
correspondence between Felix operators and certain
function or procedure names. The ones we have
used here are:
<pre>
  Operator  Name
  =         set
  +         add
  *         mul
  ==        eq
</pre>

Finally, note carefully that functions bind to C++
expressions, whilst procedures bind to C++ statements.
This is why the set procedure binding contains
a ; inside the string, as well as after it.


@h2 Seamless Binding
Felix purports to support a property called seamless binding.
What this means is that the boundary between C++ and Felix
code is fluid. To illustrate this, lets consider
a version of the above code written entirely in Felix.


You can use a compound statement as well.
@flx-and-expect tut/embedding/bind-1.02-0
The difference between these two programs is that
in the second one, gauss is a concrete
non-primitive Felix data type.
In the first program, gauss is an abstract
data type, together with a binding specifying
the semantics in C++.

As you can guess, the whole of the program
could have been written in C++ rather than
Felix.

It's up to you to choose what parts of your Felix
program are written directly in C++, and which parts
are written in Felix: since Felix is a C++ code generator,
it all ends up as C++ anyhow.

Usually, you'll write Felix, except when you have
an existing code base containing useful types
you need to work with.

@h2 Binding Shortcuts
For your convenience, the ctypes declaration
allows multiple type bindings to be defined
at once. Each Felix name must also be a c identifier
representing a type in C.

@flx-and-expect tut/embedding/bind-1.03-0

@h2 Embedding C++
We have seen that we can use binding definitions to
embed C++ constants, expressions, and procedures
into Felix code, and we can use the
{header}
statement
to embed header text in the header (.hpp) file generated by Felix.

You can also use the
{body}
statement to embed C++ definitons
in the body file Felix generates. Header text is concatenated
and emitted in the header file after Felix standard definitions
but before any bindings, and so is often used to
embed include directives.

Body code is also collected and emitted at the top of
the body (.cpp) file.

It is also possible to use the {code}
statement to embed statements directly in procedures.
This is much the same as the body statement, except
that it is an executable Felix statement, and is emitted
in the place it is written.
For example:

@flx-and-expect tut/embedding/bind-1.04-0

@h2 Operator dot
For primitive types, x.name is converted to
<pre>
  get_name x
</pre>
This means a C primitive type can be accessed
using the dot notation provided you supply
appropriate projection functions.
@
@flx-and-expect tut/embedding/bind-1.05-0

In part 1, the functions get_x and get_y
are defined by binding, but the dot notation
is used to call them.

@obsolete
What this means is that for an arbitrary C++ type,
you can create an abstract binding, and define
get methods which can be called using dot notation.
Just name the methods 'get_' something.
@
[The above works but is obsolete, since {x.f} maps to
{f x} there's no need for get methods]

It is also possible to access a Felix struct from
C++: the members have the same name in Felix and C.
[The C++ name of the struct type is not the same
as the Felix name however]

@h2 Generic primitive bindings
Felix provides a way of creating generic primitive bindings.
A generic binding is a binding to a family of C++ types,
functions, or procedured, parameterised by one or more
types. Generic bindings are roughly equivalent to
templates, and can be used to bind to templates,
although that isn't the only use.

Here is a simple example illustrating
generic primitive bindings.
@flx-and-expect tut/embedding/bind-1.06-0

@h2 Header and body tags
Header and body statements may include tag names
which can be refered to in requires clauses of
binding definitions.

Tagged bodies and headers
are only emitted if a used primitive type, constant,
function or procedure requires them.

Untagged headers and bodies are tagged with the
synthesised name _root.
Every primitive function, procedure, type, or constant
requires all visible untagged headers and bodies, that is,
they all implicitly require _root.

Root requirements are inherited: each untagged header
or body requires its parents _root (if it has one).

The effect is that if no primitives are used, no
header or body code will be generated. If you really
need to unconditionally force execution of
some C code, you should be using the 'code' primitive.
Header and body statements are intended for declarations
and definitions.

The same tag can be used on more than one code insertion
statements: this is typically useful on a header-body pair.

@flx-and-expect tut/embedding/bind-1.07-0

Header and body statements can also have requirements.
We can reorganise the previous example using this fact.

@flx-and-expect tut/embedding/bind-1.07-1

Naked requires clauses can also be used.
They can define dependencies, or simply specify
existing tagged requirements are roots.

@flx-and-expect tut/embedding/bind-1.07-2

You can also use qualified names to refer to tags defined
inside modules, unless they're marked private of course.

@flx-and-expect tut/embedding/bind-1.07-3

The next example demonstrates untagged bodies at work.

@flx-and-expect tut/embedding/bind-1.07-4

Here you can see that insertions can be given
literally too:

@flx-and-expect tut/embedding/bind-1.07-5

Here's an example demonstrating polymorphic insertions.

@flx-and-expect tut/embedding/bind-1.07-6

@h2 cstruct declaration
The cstruct keyword can be used like struct,
and has the same effect, except that no struct
is actually generated by Felix, instead, the nominated struct
is assumed to be defined in embedded C/C++ header
code somewhere.

@caveat
cstruct isn't very useful in C++ because there's no way
to specify the namespace.
@
@flx-and-expect tut/embedding/bind-1.08-0

@h2 bodyless fun, proc, const declarations
It is allowed to omit the C definition of
primitive functions, procedures, and constants.
Felix will generate the body for a function
or procedure to call the C function or procedure
with the same name and given arguments,
and a const will refer to a C entity of the
same name.

@flx-and-expect tut/embedding/bind-1.09-0

@h2 C functions
Felix can be forced to generate C/C++ style functions.
The type:
@felix
  int * int --> int
@
with a long arrow denotes a C style function. The keywords
cfun and cproc introduce such functions. C functions
can be passed by value as in C, and are represented
by the usual C function pointer.

C functions and procedures have no access to global
variables or the garbage collector, and they use
the system standard calling conventions for a
C++ function.

@flx-and-expect tut/embedding/bind-1.11-0
@h2 Callbacks
A callback function is a C function designed by extenal code.
Typically a pointer to the function is stored in a stucture directly,
or, it is passed as an argument to a registering function.

In both cases it is usual to find that the C function has a {void*}
argument often named {client_data}. This is a pointer to some data
the function uses by casting to a specific type. The pair consisting
of the callback function and the client_data are equalivalent to
a {closure}. In OO systems closures are sometime called applicative
objets, in C++ unfortunatelyt the name {functor} is abused for
the same idea. In Felix, all function variables are closures
over the environment of the function at the time the variable is assigned.

In Felix, you can specify a C style callback like this:
@felix
callback fun f: int * f -> int;
@
This is actually a definition of a C function which acts
as a wrapper for a felix function! It is used like this:
@felix
fun g(x:int)=> x + x + 1;
print$ f(2, g); endl;
@
Here, {f} calls {g}, passing to g the argument 2. The key thing to note
is that {f} is a C function, whereas {g} is a Felix function.
The function {f} accepts a Felix function in the argument position
where its own name {f} is used as a marker. That Felix function has the type
that {f} does with the marker argument removed, so the types of {f} and {g}
are given by:
@felix
  fun f: int * (int -> int) --> int;
  fun g: int -> int;
@
The arguments to {g} are collected by the call to {f}, and the {g}
is applied to them. Here is a complete example:

@flx-and-expect tut/embedding/bind-1.10-0

You may ask, what is the point of all this? In fact there is a problem.
The idea is that we can register the pair {f,g} with a callback registry
such as an event manager. When an event occurs, the event manager calls
{f} passing the actual even handler written in Felix, {g} to {f} as
client data, along with other argument such as the event type.

There is however a subtle problem here. In order for the demo Felix code above
to work, the type of {f} most be:
@felix
  fun f: int * (int -> int) --> int;
@
Unfortunately a callback in a C system is going to require this type:
@felix
  fun f: int * address --> int; // address is a void*
@
This means we have to cast the type of the C function to register it,
which unfortunately is not only not allowed in C or C++, it is also hard
to do in Felix because the cast has to be done in C code and we don't
know the name of the type above, if indeed Felix even generates such a name.
This needs to be fixed!

